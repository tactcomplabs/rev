#!/bin/bash
#
# This pre-commit hook reformats text files to meet coding guidelines.
#
# Based on https://github.com/rocm/rocBLAS
#
# shellcheck enable=all
# shellcheck disable=2034,2059,2250,2310,2312

set_shell_options() {
    set -eEu -o pipefail
    shopt -s nocasematch
    export PATH=$PATH:/usr/bin:/bin
    exec >&2
}

# Terminal colors
set_colors() {
    if [[ -z ${NO_COLOR+x} ]] && tty -s <&2; then
        RED="\033[91m"
        YELLOW="\033[93m"
        GREEN="\033[92m"
        END="\033[0m"
    else
        RED=
        YELLOW=
        GREEN=
        END=
    fi
}

usage() {
    cat<<EOF
Usage: pre-commit [ --reformat] [ --nostage ] [ file1 ] [ file2 ] [ file3 ] ...

Format files prior to commit so that they match style guidelines

Normally called before commit, but if files are explicitly specified, reformats
them in-place without respect to commits.

Options:
   --reformat   Reformat all files in the source tree, rather than staged files
   --nostage    Do not add files modified by pre-commit to the staging area
EOF
    exit 1
}

# Parse command-line options
parse_options() {
    FILES=()
    REFORMAT=
    NOSTAGE=
    EXPLICIT_FILES=
    local endopts=
    for opt in "$@"; do
        if [[ -n $endopts ]]; then
            FILES+=("$opt")
        else
            case $opt in
                --)         endopts=1  ;;
                --reformat) REFORMAT=1 ;;
                --nostage)  NOSTAGE=1  ;;
                -*)         usage      ;;
                *)          FILES+=("$opt")
            esac
        fi
    done
    if [[ ${#FILES[@]} -ne 0 ]]; then
        EXPLICIT_FILES=1
        NOSTAGE=1
    fi
}

# Check for existence of clang-format or print error message on how to install
check_clang_format() {
    if ! command -v clang-format >/dev/null; then
        printf "${RED}\nError: clang-format not found\n"
        INSTALL=
        if [[ $OSTYPE = darwin* ]]; then
            if command -v brew >/dev/null; then
                INSTALL="brew install clang-format"
            fi
        elif [[ $OSTYPE = linux* ]]; then
            if [[ -f /etc/redhat-release ]]; then
                if command -v dnf >/dev/null; then
                    INSTALL="sudo dnf install clang-format"
                elif command -v yum >/dev/null; then
                    INSTALL="sudo yum install clang-format"
                fi
            elif [[ -f /etc/debian_version ]] && command -v apt-get >/dev/null; then
                INSTALL="sudo apt-get install clang-format"
            fi
        fi
        if [[ -n $INSTALL ]]; then
            printf "To install clang-format, run:\n\n%s\n${END}" "$INSTALL"
        else
            printf "Install clang-format and make sure it is in PATH.\n${END}"
        fi
        exit 1
    fi
}

# Test a file for changes and add them to the Git commit if changed
detect_change() {
    if ! cmp -s "$1" "$2"; then
        printf "${YELLOW}$3${END}\n" "$1"
        cp -f "$2" "$1"
        if [[ -z $EXPLICIT_FILES && -z $NOSTAGE ]]; then
            git add -u "$1"
        fi
    fi
}

# Generate list of modified files
# If --reformat is used, all files are reformatted
get_files() {
    if [[ -n $EXPLICIT_FILES ]]; then
        # cd to this script's directory before running clang-format
        # so that the .clang-format from this script's repo is used
        REPO=$(dirname "$0")
    else
        # Do everything from top level
        REPO=$(git rev-parse --show-toplevel)
        cd "$REPO"
        if [[ -n $REFORMAT ]]; then
            while IFS= read -r -d $'\0' FILE; do
                FILES+=("$FILE")
            done < <(git ls-files -z --exclude-standard)
        else
            if git rev-parse --verify HEAD >/dev/null 2>&1; then
                against=HEAD
            else
                # Initial commit: diff against initial commit
                against=$(git log --reverse --pretty=format:%H | head -1)
            fi
            while IFS= read -r -d $'\0' FILE; do
                FILES+=("$FILE")
            done < <(git diff-index -z --cached --name-only "$against")
        fi
    fi
}

# Test if argument is a text file
# git grep tests whether Git considers it a text file
# If files were explicitly specified, they are assumed to be text files
is_text_file() {
    [[ -n $EXPLICIT_FILES ]] || git grep -Iqe . -- "$1"
}

# Test if argument is a C/C++ file
is_cxx_file() {
    case $1 in
        *.c|*.h|*.cc|*.hpp|*.cpp|*.cxx) true ;;
        *) false
    esac
}

reformat_files() {
    # Temporary file for reformatting
    temp=$(mktemp)
    trap 'rm -f "$temp"' EXIT

    # Get the list of files into FILES
    get_files

    errors=false
    flake8_warning=false

    # Fix formatting on text files
    for file in "${FILES[@]}"; do
        if [[ -f $file ]] && is_text_file "$file"; then
            # Replace non-ASCII characters with ASCII equivalents
            iconv -s -f utf-8 -t ascii//TRANSLIT "$file" > "$temp"
            detect_change "$file" "$temp" "%s: Converting non-ASCII characters to ASCII equivalents"

            # Change the copyright date at the top of any text files
            if perl -pe 'INIT { exit 1 if !-f $ARGV[0] || -B $ARGV[0]; $year = (localtime)[5] + 1900 } s/^([*\/#\/"*[:space:]]*)Copyright\s+(?:\(C\)\s*)?(\d+)(?:\s*-\s*\d+)?(?=\s+Tactical Computing)/qq($1Copyright (C) $2@{[$year != $2 ? "-$year" : ""]})/ie if $. < 10' "$file" > "$temp"; then
                detect_change "$file" "$temp" "%s: Changing copyright date"
            fi

            # Run clang-format on C/C++ files
            if is_cxx_file "$file"; then
                check_clang_format
                (cd "$REPO" && clang-format) < "$file" > "$temp"
                detect_change "$file" "$temp" "%s: Reformatting with clang-format according to coding guidelines"
            fi

            # Remove trailing whitespace at end of lines
            sed -e 's/[[:space:]]*$//' < "$file" > "$temp"
            detect_change "$file" "$temp" "%s: Removing trailing whitespace at line endings"

            # Add missing newline at EOF
            awk 1 < "$file" > "$temp"
            detect_change "$file" "$temp" "%s: Adding missing newline at end of file"

            # Python files
            if [[ $file = *.py ]]; then
                if command -v flake8 >/dev/null 2>&1; then
                    flake8 --color=always --max-line-length 131 "$file" || errors=true
                else
                    printf "${YELLOW}Warning: flake8 utility not found. $file not checked with flake8.${END}\n"
                    if [[ $flake8_warning = false ]]; then
                        flake8_warning=true
                        printf "${YELLOW}\nTo Install flake8, type:\n\npip install flake8\n\n${END}"
                    fi
                fi
            fi

            # Shell scripts
            if [[ $file = *.sh ]]; then
                if command -v shellcheck >/dev/null 2>&1; then
                    shellcheck --color=always "$file" || errors=true
                else
                    printf "${YELLOW}Warning: shellcheck utility not found. $file not checked with shellcheck.${END}\n"
                fi
            fi
        fi
    done

    if [[ $errors = true ]]; then
        exit 1
    fi
}

# Main Program
set_shell_options
set_colors
parse_options "$@"
reformat_files
